## 散列表

> 对于同样的输入，散列表必须返回同样的输出，这一点很重要。如果不是这样的，就无法找到你在散列表中添加的元素！

> 可以立即获取数组中的元素，而散列表也使用数组来存储数据，因此其获取元素的速度与数组一样快。


### 散列表应用案例
##### 1. 将散列表用于查找
散列表被用于大海捞针式的查找。例如，你在访问像http://adit.io这样的网站时，计算机必须将adit.io转换为IP地址。 
```
ADIT.IO -> 173.255.248.55
// 无论你访问哪个网站，其网址都必须转换为IP地址
GOOGLE.COM -> 74.125.239.133
FACEBOOK.COM -> 173.252.120.6
SCRIBD.COM -> 23.235.47.175
```
这不是将网址映射到IP地址吗？好像非常适合使用散列表啰！这个过程被称为DNS解析（DNS resolution），散列表是提供这种功能的方式之一。

##### 2. 防止重复
防止重复投票的伪代码：
```
voted = {} 
def check_voter(name): 
 if voted.get(name): 
 print "kick them out!" 
 else: 
 voted[name] = True 
 print "let them vote!" 


我们来测试几次。 
>>> check_voter("tom") 
let them vote! 
>>> check_voter("mike") 
let them vote! 
>>> check_voter("mike") 
kick them out! 
```
首先来投票的是Tom，上述代码打印let them vote!。接着Mike来投票，打印的也是letthem vote!。然后，Mike又来投票，于是打印的就是kick them out!。    
如果你将已投票者的姓名存储在列表中，这个函数的速度终将变得非常慢，因为它必须使用简单查找搜索整个列表。但这里将它们存储在了散列表中，而散列表让你能够迅速知道来投票的人是否投过票。使用散列表来检查是否重复，速度非常快。
##### 3. 将散列表用作缓存
具体的代码如下。 
```
cache = {} 

def get_page(url): 
 if cache.get(url): 
    return cache[url] 
 else: 
    data = get_data_from_server(url) 
    cache[url] = data 
    return data 
```
仅当URL不在缓存中时，你才让服务器做些处理，并将处理生成的数据存储到缓存中，再返回它。这样，当下次有人请求该URL时，你就可以直接发送缓存中的数据，而不用再让服务器进行处理了。

### 冲突
冲突原因：给两个键分配的位置相同    
解决办法：如果两个键映射到了同一个位置，就在这个位置存储一个链表

+ 散列函数很重要。前面的散列函数将所有的键都映射到一个位置，而最理想的情况是，散列函数将键均匀地映射到散列表的不同位置。
+ 如果散列表存储的链表很长，散列表的速度将急剧下降。然而，如果使用的散列函数很好，这些链表就不会很长
+ 散列函数很重要，好的散列函数很少导致冲突

### 性能
+ 简单查找的时间复杂度为：O(n)
+ 二分查找的时间复杂度为：O(log n)
+ 散列表查找的时间复杂度为：O(1)

+ 散列表： 查找平均情况O(1)，查找最糟情况O(n)，插入和删除平均情况O(1)，插入和删除最糟情况O(n)
+ 数组：查找O(1)，插入和删除O(n)
+ 链表：查找：O(n)，插入和删除O(1)

在平均情况下，散列表的查找（获取给定索引处的值）速度与数组一样快，而插入和删除速度与链表一样快，因此它兼具两者的优点！但在最糟情况下，散列表的各种操作的速度都很慢。因此，在使用散列表时，避开最糟情况至关重要。为此，需要避免冲突。而要避免冲突，需要有： 
+ 较低的填装因子；
+ 良好的散列函数。
散列函数的结果必须是均匀分布的，这很重要。它们的映射范围必须尽可能大。最糟糕的散列函数莫过于将所有输入都映射到散列表的同一个位置。

### 总结
+ 你可以结合散列函数和数组来创建散列表。
+ 冲突很糟糕，你应使用可以最大限度减少冲突的散列函数。
+ 散列表的查找、插入和删除速度都非常快。
+ 散列表适合用于模拟映射关系。
+ 一旦填装因子超过0.7，就该调整散列表的长度。
+ 散列表可用于缓存数据（例如，在Web服务器上）。
+ 散列表非常适合用于防止重复。
