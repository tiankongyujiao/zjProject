## 选择排序
### 数组和链表
#### 数组
+ 内存地址是连续的，如果预留空间不够，要全部重新转移地址
+ 需要随机地读取元素时，数组的效率很高，因为可迅速找到数组的任何元素
+ 数组的读取时间复杂度是O(1)，支持随机访问，插入的时间复杂度是O(n)，删除的时间复杂度是O(n)----o(n)表示线性时间，O(1)表示常量时间
+ 在同一个数组中，所有元素的类型都必须相同

#### 链表
+ 内存地址非连续，只需将其放入内存，并将其地址存储到前一个元素中
+ 链表的优势在插入元素方面
+ 在需要读取链表的最后一个元素时，你不能直接读取，因为你不知道它所处的地址，必须先访问元素#1，从中获取元素#2的地址，再访元素#2并从中获取元素#3的地址，以此类推，直到访问最后一个元素。需要同时读取所有元素时，链表的效率很高：你读取第一个元素，根据其中的地址再读取第二个元素，以此类推。但如果你需要跳跃，链表的效率真的很低
+ 链表的读取时间复杂度是O(n)，插入的时间复杂度是O(1)，删除的时间复杂度是O(1)----o(n)表示线性时间，O(1)表示常量时间

> 插入和删除操作使用链表更快，只需要修改前一个元素的指向，读取操作使用数组更快

### 选择排序
+ 选择排序的时间复杂度用大O表示法表示为：O(n²)
+ 选择排序是每次找到arr最大的元素添加到newArr，并删除arr找出来的最大值，然后再找arr最大值添加到newArr，依次循环直到arr为空，此时newArr就是一个递减的顺序。