## 快速排序

##### 分而治之（D&C）：一种著名的递归式问题解决方法
+ 学习分而治之。有时候，你可能会遇到使用任何已知的算法都无法解决的问题。优秀的算法学家遇到这种问题时，不会就此放弃，而是尝试使用掌握的各种问题解决方法来找出解决方案。分而治之是你学习的第一种通用的问题解决方法。
+ 学习快速排序——一种常用的优雅的排序算法。快速排序使用分而治之的策略。


### 快速排序
快速排序是一种排序算法，速度比选择排序快得多，实属优雅代码的典范。     
使用D&C解决问题的过程包括两个步骤。     
(1) 找出基线条件，这种条件必须尽可能简单。     
(2) 不断将问题分解（或者说缩小规模），直到符合基线条件。     
例子： 给定一个数字数组[2,4,6],你需要将这些数字相加，并返回结果。使用循环很容易完成这种任务。    
```
def sum(arr): 
 total = 0 
 for x in arr: 
 total += x 
 return total 
print sum([1, 2, 3, 4]) 
```
但如何使用递归函数来完成这种任务呢？ 
第一步：找出基线条件。最简单的数组什么样呢？请想想这个问题，再接着往下读。如果数组不包含任何元素或只包含一个元素，计算总和将非常容易。 因此这就是基线条件。    
第二步：每次递归调用都必须离空数组更近一步。如何缩小问题的规模呢？    
①sum([2,4,6])和②2+sum([4,6])等效    
这两个版本的结果都为12，但在第二个版本中，给函数sum传递的数组更短。换言之，这缩小了问题的规模！     
函数sum的工作原理类似于这样：接受一个列表，如果列表为空，就返回0，否则，计算列表中第一个数字外的其他数字的综合，将其与第一个数字相加，再返回结果。

> 编写涉及数组的递归函数时，基线条件通常是数组为空或只包含一个元素。陷入困境时，请检查基线条件是不是这样的。    

##### 如何使用快速排序对数组进行排序
> 归纳证明：归纳证明是一种证明算法行之有效的方式，它分两步：基线条件和归纳条件。是不是有点似曾相识的感觉？例如，假设我要证明我能爬到梯子的最上面。递归条件是这样的：如果我站在一个横档上，就能将脚放到下一个横档上。换言之，如果我站在第二个横档上，就能爬到第三个横档。这就是归纳条件。而基线条件是这样的，即我已经站在第一个横档上。因此，通过每次爬一个横档，我就能爬到梯子最顶端。
 
> 对于快速排序，可使用类似的推理。在基线条件中，我证明这种算法对空数组或包含一个元素的数组管用。在归纳条件中，我证明如果快速排序对包含一个元素的数组管用，对包含两个元素的数组也将管用；如果它对包含两个元素的数组管用，对包含三个元素的数组也将管用，以此类推。因此，我可以说，快速排序对任何长度的数组都管用。这里不再深入讨论归纳证明，但它很有趣，并与D&C协同发挥作用。

+ 二分查找：O(log n)
+ 简单查找：O(n)
+ 快速排序：O(n log n)
+ 选择排序：O(n²)
+ 旅行商问题算法：O(n!)

### 总结
+ D&C将问题逐步分解。使用D&C处理列表时，基线条件很可能是空数组或只包含一个元素的数组。
+ 实现快速排序时，请随机地选择用作基准值的元素。快速排序的平均运行时间为O(n log n)。 
+ 大O表示法中的常量有时候事关重大，这就是快速排序比合并排序快的原因所在。
+ 比较简单查找和二分查找时，常量几乎无关紧要，因为列表很长时，O(log n)的速度比O(n)快得多。
