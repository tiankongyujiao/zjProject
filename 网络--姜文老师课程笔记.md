## 网络课后笔记
### 1. 中继器，集线器，交换机，路由器，网关的作用
+ 中继器：中继器就是在两台机器之间的信号放大器，有两个口。（双绞线最大传输距离100M ，中继器可以延长网络传输的距离，对衰减的信号有放大在生的功能。）
+ 集线器（物理层）：集线器也是在两台机器之间的信号放大器，有多个口，两个口的集线器就是中继器。集线器在收到一个信号以后是采用广播的形式发送个连接在该集线器上的其他机器的，浪费性能。    
集线器是半双工通信，所有的端口共享一条宽带，同一时刻只能有两个端口传输数据。
+ 交换机（数据链路层）：交换机是对集线器的优化，交换机在收到信号以后，首次会采用广播的形式发送给连接在该交换机上的其他机器，发送以后会获得被发送方的MAC地址（屋里地址），交换机有个MAC表，记录在MAC表里，下次再有信号来的时候会根据MAC表匹配，匹配不上的不发送，优化了性能（根据数据包的MAC地址转发数据，而不是广播形式）。    
交换机上的两个端口通信时，它们之间的通道是相互独立的，可以实现全双工通信。两个端口同时收发数据。     
交换机主要用于组建局域网，用在局域网中，实现了特定网络内的数据交换。
+ 路由器（网络层）：用的是路由表，转发依据IP地址（网络地址）。
路由器主要用于把交换机组装好的局域网相互连接起来，或者接入Internet，实现了不同网络之间的数据转发。    
没有WAN的路由器可以看做是交换机（路由器有LAN口和WAN口）。     
路由器上面的接口LAN，是电脑与路由器的连接口。是连接的内网，家里的电脑网线都可以用LAN接口连接。    
WAN则是交换机或者MODEM与路由器的连接口。通俗来讲，就是网线的接口，外网和网线通过这个口来连接。MODEM（猫），也是连接WAN口。       
路由器一般充当网关，路由器会将本地IP地址进行NAT。
+ 网关（应用层）：网关在网络层以上实现网络互连，是复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关既可以用于广域网互连，也可以用于局域网互连。    
网关实质上是一个网络通向其他网络的IP地址。比如有网络A和网络B，网络A的IP地址范围为“192.168.1.1~192. 168.1.254”，子网掩码为255.255.255.0；网络B的IP地址范围为“192.168.2.1~192.168.2.254”，子网掩码为255.255.255.0。在没有路由器的情况下，两个网络之间是不能进行TCP/IP通信的，即使是两个网络连接在同一台交换机（或集线器）上，TCP/IP协议也会根据子网掩码（255.255.255.0）与主机的IP 地址作 “与” 运算的结果不同判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。网络A向网络B转发数据包的过程。    
今天很多局域网采用都是路由来接入网络，因此通常指的网关就是路由器的IP。

### 2. 七层模型
+ 应用层：用户最终使用的接口；
+ 表示层：数据的表示、安全、压缩；
+ 会话层：建立和管理会话的传输层：（主要提供安全及数据完整性保障）网络层不可靠，保证可靠的传输；
+ 网络层：（主要关心的是寻址） ，进行逻辑寻址，定位到对方，找到最短的路；
+ 数据链路层： （主要关心两个设备之间传递数据），建立逻辑链接，将数据组合成数据帧进行传递 （差错校测，可靠传输）；
+ 物理层：（核心是传输数据比特流），不关心具体的传输媒体（双绞线、光纤、同轴电缆、无线...）

### 3. TCP/IP协议
> 协议的定义：协议就是约定和规范。

数据链路层、物理层 ：物理设备 (在五层模型中能称之为协议的都在三层以上)。    
#### 网络层：
+ （1）IP协议：寻址通过路由器查找，将消息发送给对方路由器，通过ARP协议,发送自己的mac地址。
+ （2）ARP 协议：Address Resolution Protocol 根据目的IP地址，解析目的mac地址 （局域网）。**有了源mac地址和目标mac地址，就可以传输数据包了** 。
#### 传输层：
+ （1）TCP协议：面向连接。TCP 传输控制协议 Transimision Control Protocal 可靠、面向连接的协议,传输效率低 (在不可靠的IP层上建立可靠的传输层)。 TCP提供全双工服务，即数据可在同一时间双向传播。**TCP 对数据进行分段打包传输，对每个数据包编号控制顺序** 。
TCP协议头部总共是20个字节，其中包括：    
①：源端口号（发送TCP进程对应的端口号），目标端口号（目标端接收进程的端口号）；    
②：序列号：32位，对数据包进行标记，方便重组；    
③：确认序列号：期望发送方下一个发送的数据的编号；    
④：4位首部长度，URG：紧急信号，ACK：确认信号，PSH：应该从TCP缓冲区读走数据，RST：断开重连，SYN：建立连接，FIN：断开连接。16位的窗口大小（滑动窗口）。    
⑤：校验和。    
⑥：紧急指针。
+ （2）UDP协议：面向无连接的。UDP发出请求后，不考虑对方是否能接收到、内容是否完整、顺序是否正确。 收到数据后也不会进行通知。首部结构简单，在数据传输时能实现最小的开销。    
> TCP拥塞处理 （队头阻塞，慢启动， 短连接）
#### 应用层协议：
+ （1）HTTP 
+ （2）DNS：DNS服务器是进行域名和与之对应的IP地址转换的服务器。顶级域名：.com；二级域名：.com.cn；三级域名：www.zf.com.cn, 有多少个点就是几级域名。    
访问一个网址，域名解析的过程，例如访问：zf.com.cn：    
①：操作系统里会对 DNS 解析结果做缓存，如果缓存中有直接返回IP地址；        
②：查找C:\WINDOWS\system32\drivers\etc\hosts 如果有直接返回IP地址；    
③：通过DNS服务器查找离自己最近的根服务器，通过根服务器找到.cn服务器，将ip返回给DNS服务器；    
④：DNS服务器会继续像此ip发送请求，去查找对应.cn下.com对应的ip，依次类推...；    
⑥：获取最终的ip地址。缓存到DNS服务器上。    
DNS服务器会对ip及域名进行缓存, 采用的是udp（无连接）。
+ （3）FTP
+ （4）TFTP
+ （5）SMTP
+ （6）DHCP：通过DHCP自动获取网络配置信息 （动态主机配置协议Dynamic Host Configuration Protocol）我们无需自己手动配置IP

### 4. TCP的三次握手和四次挥手
建立连接需要三次握手，断开链接四次握手。    
（1）建立连接的过程：    
①：客户端主动请求服务器（SYN），设置Seq=0;    
②：服务器应答（ACK）Ack = 1(客户端的Seq) + 1，并向客户端请求（SYN）：Seq=0;    
③：客户端应答（ACK）：Seq=1(这个1是服务端响应的Ack的值)，Ack=1(应答)。    
形象的描述：1）我能主动给你打电话吗？ 2）当然可以啊！那我也能给你打电话吗？3）可以的呢，建立连接成功！
（2）传输数据的过程：    
①：客户端主动给服务器推送数据(PSH,ACK)：Seq=1,Ack=1,len=5(客户端向服务器发送5个字节);    
②：服务器响应客户端（ACK）：Seq=1,Ack=6(6=客户端的Seq+len)；    
③：服务器给客户端推送响应的数据(PSH,ACK)：Seq=1,ACK=6,len=2(服务器向客户端发送2个字节)；    
④：客户端应答(ACK)：Ack=3(服务端的Seq+len),Seq=6。    
（3）断开链接的过程：    
①：客户端主动发起断开连接的请求(FIN,ACK)：Seq=6,Ack=3;     
②：服务器应答客户端收到断开的消息的请求(ACK)：Ack=7(客户端的Seq+1),Seq=3;    
③：服务器要和客户端断开(FIN,ACK)：Ack=7,Seq=3;    
④：客户端应答服务器收到断开消息的请求(ACK)：Ack=4(客户端的Seq+1),Seq=7。    
形象的描述：1）我们分手吧 2）收到分手的信息3）好吧，分就分吧 4）行，那就到这里了。    

> 为了防止最终的ACK丢失，发送ACK后需要等待一段时间，因为如果丢包服务端需要重新发送FIN包，如果客户端已经closed，那么服务端会将结果解析成错误。 从而在高并发非长连接的场景下会有大量端口被占用。

### 5. TCP的滑动窗口和队头阻塞
** 滑动窗口 **：TCP是全双工的，所以发送端有发送缓存区；接收端有接收缓存区，要发送的数据都放 到发送者的缓存区，发送窗口（要被发送的数据）就是要发送缓存中的哪一部分。核心是流量控制：在建立连接时，接收端会告诉发送端自己的窗口大小（rwnd）,每次接收端收到数据后都会再次确认（rwnd）大小，如果值为0，停止发送数据。 （并发送窗口探测包，持续监测窗口大小。    
** 粘包 **：a. Nagle算法的基本定义是任意时刻，最多只能有一个未被确认的小段 (TCP内部控制)；    
    b. Cork算法当达到MSS(Maximum Segment Size )值时统一进行发送（此值就是帧的大小 - ip头 - tcp头 = 1460个字节）理论值。    
队头阻塞：出现队头阻塞的原因是滑动窗口滑动的前提是某个数据包之前的数据包已经全部传送完毕，比如：收到了第三个数据包，那么要等到前面两个数据包都收到以后滑动窗口才能根据返回的窗口大小滑动到以数据包4开始的位置，并根据返回的窗口大小决定当前的滑动窗口大小，所以会有队头阻塞的问题。    

### 6. HTTP缓存：
强缓存：强缓存是服务器在响应头中返回了过期时间，如果没有过期，则强制使用浏览器或者本地的缓存（disk cache）。强缓存的状态码是200。    
协商缓存：指的是本地或者浏览器也有缓存，但是还是会向服务器发送请求，服务器根据一定的规则对比看请求的文件是否被修改了，如果被修改了则返回新的内容，状态码是200，如果没有被修改，则返回304状态码，并让浏览器去使用浏览器自身或者本地的缓存，服务器不返回请求的文件，节省了带宽。    

### 7. HTTP和HTTPS
> HTTP采用明文传输，中间人可以获取到明文数据 （从而实现对数据的篡改）。这时候HTTPS就登场了！HTTPS是什么呢？HTTPS = HTTP + SSL/TLS ， SSL 安全套接层（Secure Sockets Layer） 发展到 v3时改名为TLS 传输层安全(Transport Layer Security)，主要的目的是提供数据的完整性和保密性。   

加密方法有：     
（1）对称加密：客户端和服务端公用一个公钥：这样中间人可以拦截到公钥，不安全。    
（2）非对称加密：客户端和服务端都各有一个公钥和私钥，双方交换公钥后使用对方的公钥加密，然后用自己的私钥解密。但是会有两个问题：         
 ①：非对称加密最大的问题出现在了第一步公钥传递上面，我怎么信任你这把公钥呢？要知道这个地方还是在裸奔啊，如果出现了“中间dog”故意使坏，破解不了你但是要搞残你，将双方发送给对方的公钥篡改，冒充成随便一个公钥，那么双方用这个假公钥加密对方永远都解密不出来数据。      
 ②：第二是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。
（3）混合加密：通信刚开始的时候使用非对称算法，交换秘钥。在客户端生成会话秘钥后传送给服务端，后续通信采用对称加密的方式。不安全：会有中间人攻击：指攻击者与通讯的两端分别创建独立的联系,并交换其所收到的数据。     

#### CA认证（数字认证机构）
因为谁都可以发布公钥，所以我们需要验证对方身份。防止中间人攻击。    

CA认证防止了中间人篡改公钥，中间人只能获取公钥，修改不了，中间人没有私钥，单纯获取公钥没有用，起到了安全的作用。    
实现的方法：服务器发送公钥给CA，CA有自己的公钥和私钥，CA用私钥给服务器传送过来的公钥进行了数字签名加密，对数字证书进行hash，采用CA私钥对hash值进行加签，然后把这个证书返回给客户端，操作系统和浏览器都内置了CA的公钥，可以用这个CA的公钥进行解密证书获取公钥，要校验证书的签名，证明这个证书确实是CA发的；中间人也能获取公钥，但是修改不了公钥，因为修改了以后，CA上的数字签名就对不上了，就是攻击者。   
发送给客户端的证书有数字签名：sign = encrypt(hash("证书机构" + "证书有效期" + "证书所有者" + "公钥")) ，还有证书机构，证书有效期，证书所有者。       
客户端校验签名的步骤:    
①：客户端从系统根证书中取出对应CA的公钥，然后对签名解密获取到hash值。    
②：客户端使用相同的方式（证书机构+证书有效期+证书所有者+公钥）拼接证书信息，使用相同算法得到hash值。    
③：比较解密出来的hash值和客户端拼接的hash值是否相同，相同则通过。 

客户端获取到从CA里面获取到的公钥以后，用CA公钥对“会话秘钥”进行加密，服务端收到以后使用私钥（CA返给服务端的私钥，在HTTPS中只有服务端才有这个私钥，客户端没有）对加密后的“会话秘钥”进行解密，双方都有会话秘钥以后，传输数据就使用“会话秘钥”的对称加密算法进行的。    

> 非对称加密只用来传输“会话秘钥”，实际数据传输用的对称加密，解决了非对称加密解密速度慢的问题，
CA机构数字证书验证公钥，解决公钥传输的信任问题
 
> HTTPS尽管可以保护数据在传输环节的安全，但HTTPS不是万能的，不能解决所有的安全问题。HTTPS无法解决跨站脚本XSS攻击、跨站资源冒用CSRF、跨站脚本跟踪XST、SQL注入攻击、病毒攻击，HTTPS依然无法解决。解决这些安全问题，需要在通信的终端采取措施来保证用户数据安全。
