1. crp: CRP 是 critical rendering path 的缩写，指的是当用户输入 url 到显卡把浏览器上的内容呈现给用户这段过程。这段时间的性能优化是重要的。
2. url---->页面展示
（1）URL解析
（2）缓存检查 
a. 资源文件缓存：
    强缓存：先看强缓存 ：生效，则执行强缓存 cache-control  expires  
    协商缓存：强缓存不生效，则检查协商缓存 etag  last-modified   每次要和服务器发请求，把上次拿到的修改时间和信息发给服务器，和服务器端的修改时间做对比，  
        如果不一样，则修改了，返回结果和200，如果一样则返回304，浏览器从缓存获取。  
    先检查内存，再检查硬盘   
    html页面一般不做缓存  


b. 数据缓存  
    数据get请求缓存浏览器做不了  
    客户端最常见的三种存储方案  
    localStorage：持久存储  
    sessionStorage：会话存储  
    vue/redux：页面刷新后消失  
（3）DNS解析：通过域名找到域名的外网的ip地址 ---- 缓存域名解析对应关系，减少域名解析次数  
    dns预解析：dns-prefetch    <link rel="dns-prefetch" href="" />  
（4）TCP三次握手：建立客户端和服务器间的连接通道  
（5）数据传输  
    base64:  
        正常的图片渲染过程：  
            a. HTTP网络请求  
            b. 编码  
            c. 渲染绘制  
        base64编码的图片渲染过程：  
            a. 直接绘制渲染  
    图片延时加载:  
        a. 浏览器最快反应时间5-7ms时间 防抖节流  
        b. IntersectionObserver 不兼容ie  
（6）TCP四次挥手  
（7）页面渲染  


浏览器是多线程的  

css:  
link是同步的，@import是同步的，样式少可以直接使用内嵌式，使页面加载更快  

js:  
script src是阻塞式渲染，会阻碍GUI渲染，是script异步加载的两种方式：async和defer  
async：单独搞个线程去请求资源，GUI同步渲染，请求回来以后执行js代码，GUI停止渲染，js执行完成以后继续GUI渲染。async不是按照顺序执行，哪个js先加载完先执行哪个。  
defer：单独搞个线程去请求资源，GUI同时渲染，GUI渲染完了以后再执行js  

DomContentLoaded比loaded先执行，DomContentLoaded是文档加载完成以后执行，loaded是把所有资源都加载完成以后在执行   
 
DOM层面的4中核心优化方案：  
（1）减少重排和重绘：  
    a. 不直接操作dom(vue/react)   
    b. 渲染队列机制：分离读写   
        aa. 当前上下文中遇到修改样式的代码，则放入到渲染队列当中，直到当前上下文中没有修改样式的代码了，则触发一次重排  
        bb. 遇到获取元素样式了，会刷新渲染队列，会触发一次重排：统一进行写样式，统一进行读样式（分离读写）  
    c. 元素的批量增加  
        稀疏数组：new Array(10)：不能使用forEach和map等  
        密集数组：new Array(10).fill(null)：可以使用数组方法遍历  
        aa. 文档碎片:  
        ```
            var frag = document.createDocumentFragment();  
            var arr = new Array(10).fill(null).forEach((item, index) => {
                var span = document.createElement('span');
                span.innerHTML = index + 1;
                frag.appendChild(span);
            })
            document.body.appendChild(frag);
        ```
    d. 动画运用到脱离文档流的元素上  
    e. 开启css3硬件加速，修改样式基于transform，transfrom不会引发重排  
（2）使用事件委托  
    绑在父级上，利用事件冒泡的机制，事件源来判断点击的原色，可以给动态添加的元素添加点击事件，列表点击事件节省性能（只需要开辟一个函数空间）  
（3）函数的防抖和节流  
（4）requestAnimationFrame/cancelAnimationFrame  
    电脑一秒钟刷新60次，浏览器一帧是16ms左右  
